## 해결한 문제

![image](https://github.com/SeungYeop-Han/cotejunbi/assets/106862797/ffa46899-6e53-455a-89a0-b79910f347bf)

👉🏻 [문제 링크](https://www.acmicpc.net/problem/1342)

## 문제 분석

- 길이가 n인 행운의 문자열 = 인접한 모든 문자가 다른 문자열 → 투포인터 순회
- 주어진 문자열 S를 재배치 → 문자열의 각 문자를 포함하는 중복 집합에 대한 순열 순회

## 알고리즘

```
numLuckyStrings = 0;

for-each *str* in (모든 재배치 경우) {
  if (isLuckyString(*str*)) {
    numLuckyCases++
  }
}

print(numLuckyCases)
```

## 소스 코드

    👀 눈 여겨볼 사항들
        
        1. 문자열 → 배열
        2. 배열 → 집합
        3. Set & Map
            1. Set에 add 성공 시 true, 이미 존재하는 경우 false를 반환함을 이용
            2. for-each 문을 통한 Set 순회
            3. Map 값 변경
        4. 투 포인터 비교 순회

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class Main {

    // 입력 상수
    String s;

    // 상태
    Set<Character> set = new HashSet<>();
    Map<Character, Integer> multiplicities = new HashMap<>();
    int permutationLength;
    char[] permutation;

    // 답안
    int numLuckyStrings = 0;

    void solution() {

        takeInput();
        permute(0);
        System.out.println(numLuckyStrings);
    }

    void permute(int at) {

        if (at == permutationLength) {

            if (isLuckyString(permutation)){
                numLuckyStrings++;
            }

            return;
        }

        for (char c : set) {
            if (multiplicities.get(c) == 0) {
                continue;
            }

            multiplicities.put(c, multiplicities.get(c) - 1);

            permutation[at] = c;
            permute(at + 1);

            multiplicities.put(c, multiplicities.get(c) + 1);
        }
    }

    boolean isLuckyString(char[] s) {

        /* 투 포인터로 비교 순회

            [][][][][][]...[][]
            ↑ ↑ 
            i j
              ↑ ↑ 
              i j
                    ...
                           ↑ ↑ 
                           i j
         */

        int i, j;
        for (i = 0, j = 1; j < s.length; i++, j++) {
            if (s[i] == s[j]) {
                return false;
            }
        }

        return true;
    }

    void takeInput() {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            s = br.readLine();

            permutationLength = s.length();
            permutation = new char[permutationLength];

						// 집합(set)과 중복도(multiplicities) 초기화
            for (char c : s.toCharArray()) {
                if (set.add(c)) {
                    multiplicities.put(c, 1);
                } else {
                    multiplicities.put(c, multiplicities.get(c) + 1);
                }
            }

        } catch (Exception e) {
            // do nothing
        }
    }

    public static void main(String[] args) {
        new Main().solution();
    }
}
```

![Untitled](https://github.com/SeungYeop-Han/cotejunbi/assets/106862797/412c055f-f888-4fe9-a27e-c5f4e62441aa)

---
