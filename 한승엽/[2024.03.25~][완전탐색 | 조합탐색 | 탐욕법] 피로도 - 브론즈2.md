## 해결한 문제

![image](https://github.com/SeungYeop-Han/cotejunbi/assets/106862797/a36e3cbc-5a03-4d85-b588-911a3e3a73ec)

👉🏻 [문제 링크](https://www.acmicpc.net/problem/22864)

## 접근 방식1: 탐욕법

시간당 업무량, 피로량, 그리고 휴식량이 일정하므로, 일을 할 수 있으면 일을 하고, 피로해서 일을 할 수 없으면 쉬는 방식으로 최적의 답을 찾아낼 수 있음을 직관적으로 알 수 있다.

엄밀한 증명은 나중에 탐욕법에 대해 더 자세하게 학습한 뒤 시도해 볼 계획이다.

    💡 유의 사항

    피로도는 음수가 될 수 없다.

### 소스 코드


```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

    int workDonePerHour;
    int fatigueAmountPerHour;
    int recoveryAmountPerHour;
    int fatigueThreshold;

    void solution() {
        takeInput();
        
        int workDone = 0;
        int fatigue = 0;
        for (int h = 0; h < 24; h++) {
            if ( (fatigue + fatigueAmountPerHour) <= fatigueThreshold ) {
                fatigue += fatigueAmountPerHour;
                workDone += workDonePerHour;
            } else {
                fatigue -= recoveryAmountPerHour;
                if (fatigue < 0) {
                    fatigue = 0;
                }
            }
        }

        System.out.println(workDone);
    }

    void takeInput() {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            StringTokenizer st;

            st = new StringTokenizer(br.readLine());
            fatigueAmountPerHour = Integer.parseInt(st.nextToken());
            workDonePerHour = Integer.parseInt(st.nextToken());
            recoveryAmountPerHour = Integer.parseInt(st.nextToken());
            fatigueThreshold = Integer.parseInt(st.nextToken());

        } catch (Exception e) {
            // do nothing
        }
    }

    public static void main(String[] args) {
        new Main().solution();
    }
}
```

![Untitled](https://github.com/SeungYeop-Han/cotejunbi/assets/106862797/06e79da5-b362-4a24-ab82-8ceaead40ce9)


- 그리디로 풀수만 있다면, 아주 효율적으로 문제를 해결할 수 있다.

## 접근 방식2: 완전 탐색 - 중복 순열; 가지치기 활용 ❌

### **상태 공간의 크기과 시간 제한**

하루를 1시간 단위로 24 분할한다. 각 시간 슬롯에는 일을 하거나 쉴 수 있다. 이때 가능한 경우의 수는 2^24 = 16,777,216 로 2천만번이 채 안된다. 주어진 시간인 1초 이내로 해결할 수 있을 것으로 보인다.

### 중복 순열 순회

일을 하는 것을 true, 하지 않는 것을 false로 보고 길이가 24인 중복 순열을 만들어야 한다. 24중첩 반복문을 작성할 생각이 아니라면, 재귀 함수를 이용하는 것이 좋아 보인다.

### 소스 코드

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

    // 입력 상수
    int workDonePerHour;
    int fatigueAmountPerHour;
    int recoveryAmountPerHour;
    int fatigueThreshold;

    // 답
    int maxWorkDone = 0;

    // 상태
    static boolean[] workOrRest = new boolean[] {false, true}; // work, rest
    static boolean[] hasWorkedAt = new boolean[24];

    void solution() {

        takeInput();
        permutationWithRepetition(0);
        printAnswer();
    }

    void permutationWithRepetition(int h) {

        // 하나의 경우를 완성한 경우, 일 총량 계산
        if (h == 24) {
            calculateWorkDone();
            return;
        }

        // 모든 경우 순회
        for (int i = 0; i < workOrRest.length; i++) {
            hasWorkedAt[h] = workOrRest[i];
            permutationWithRepetition(h + 1);
        }
    }

    /**
     * 0 ~ 23 시간 동안 처리된 일 총량 계산
     * 만약 기존 maxWorkDone 보다 많은 일을 처리한 경우 해당 값으로 갱신
     */
    void calculateWorkDone() {

        int fatigue = 0;
        int workDone = 0;
        for (int h = 0; h < 24; h++) {
            if (hasWorkedAt[h]) {
                workDone += workDonePerHour;
                fatigue += fatigueAmountPerHour;
            } else {
                fatigue -= recoveryAmountPerHour;
                if (fatigue < 0) {
                    fatigue = 0;
                }
            }

            if (fatigue > fatigueThreshold) {
                return;
            }
        }

        if (workDone > maxWorkDone) {
            maxWorkDone = workDone;
        }
    }

    void takeInput() {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            StringTokenizer st;

            st = new StringTokenizer(br.readLine());
            fatigueAmountPerHour = Integer.parseInt(st.nextToken());
            workDonePerHour = Integer.parseInt(st.nextToken());
            recoveryAmountPerHour = Integer.parseInt(st.nextToken());
            fatigueThreshold = Integer.parseInt(st.nextToken());

        } catch (Exception e) {
            // do nothing
        }
    }

    void printAnswer() {
        System.out.println(maxWorkDone);
    }

    public static void main(String[] args) {
        new Main().solution();
    }
}
```

![Untitled](https://github.com/SeungYeop-Han/cotejunbi/assets/106862797/abef00cf-a5fe-47fe-bc63-ab26cca50eba)

![Untitled](https://github.com/SeungYeop-Han/cotejunbi/assets/106862797/25f6ee4e-5798-482b-a36e-b832ef903471)

![Untitled](https://github.com/SeungYeop-Han/cotejunbi/assets/106862797/bf9a0621-a772-4c4f-94d4-b083f4d8b050)


- 3회 평균 수행 시간 = 941.3ms

## 접근 방식3: 완전 탐색 - 중복 순열; 가지치기 활용 ⭕

### **명백한 실패 조건을 활용한 가지치기**

피로도가 M을 넘지 않으면서 최대한 많이 하는 것이 목표이다. 해 조건은 경우 사이의 관계를 포함하고 있지만 명백한 완료 조건을 포함하지는 않는다. 다만, 피로도 한계라는 명백한 실패 조건을 포함하고 있다. 피로도가 M이 넘어가는 경우 이후로는 살펴볼 필요가 없으므로, 되추적 기법을 적용하면 문제를 효율적으로 해결할 수 있을 것으로 보인다.

- 경우 간 관계: 크기의 대소 비교가 필요하다
- 실패 조건: 피로도가 M을 초과하는 경우

### 소스 코드

    💡 유의 사항
    
    피로도 한계 검사 로직이 순회 과정 속으로 들어감에 따라, 완성된 모든 경우가 피로도 한계를 넘지 않음을 보장할 수 있음
    
    이에 따라 calculateWorkDone 함수로부터 피로도 검사 로직이 삭제됨

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

    // 입력 상수
    int workDonePerHour;
    int fatigueAmountPerHour;
    int recoveryAmountPerHour;
    int fatigueThreshold;

    // 답
    int maxWorkDone = 0;

    // 상태
    static boolean[] workOrRest = new boolean[] {false, true}; // work, rest
    static boolean[] hasWorkedAt = new boolean[24];

    void solution() {

        takeInput();
        permutationWithRepetition(0);
        printAnswer();
    }

    void permutationWithRepetition(int h) {

        // 하나의 경우를 완성한 경우, 일 총량 계산
        if (h == 24) {
            // 경우가 promising 한지 순회 과정에서 검사하므로, 피로도 한계를 넘지 않음이 보장된다.
            calculateWorkDone();
            return;
        }

        // 모든 경우 순회
        for (int i = 0; i < workOrRest.length; i++) {
            hasWorkedAt[h] = workOrRest[i];

            if (isPromising(h)) {
                permutationWithRepetition(h + 1);
            } else {
                // pruning
                return;
            }
        }
    }

    /**
     * @return 0 ~ to 시간 동안 피로도 한계 초과 시 false, 아니면 true 반환
     */
    boolean isPromising(int to) {

        int fatigue = 0;
        for (int h = 0; h <= to; h++) {
            if (hasWorkedAt[h]) {
                fatigue += fatigueAmountPerHour;
            } else {
                fatigue -= recoveryAmountPerHour;
                if (fatigue < 0) {
                    fatigue = 0;
                }
            }
        }

        if (fatigue > fatigueThreshold) {
            return false;
        }
        
        return true;
    }

    /**
     * 0 ~ 23 시간 동안 처리된 일 총량 계산
     * 만약 기존 maxWorkDone 보다 많은 일을 처리한 경우 해당 값으로 갱신
     */
    void calculateWorkDone() {

        int workDone = 0;
            for (int h = 0; h < 24; h++) {
                if (hasWorkedAt[h]) {
                    workDone += workDonePerHour;
                }
            }

            if (workDone > maxWorkDone) {
                maxWorkDone = workDone;
            }
    }

    void takeInput() {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

            StringTokenizer st;

            st = new StringTokenizer(br.readLine());
            fatigueAmountPerHour = Integer.parseInt(st.nextToken());
            workDonePerHour = Integer.parseInt(st.nextToken());
            recoveryAmountPerHour = Integer.parseInt(st.nextToken());
            fatigueThreshold = Integer.parseInt(st.nextToken());

        } catch (Exception e) {
            // do nothing
        }
    }

    void printAnswer() {
        System.out.println(maxWorkDone);
    }

    public static void main(String[] args) {
        new Main().solution();
    }
}
```

![Untitled](https://github.com/SeungYeop-Han/cotejunbi/assets/106862797/e0bbbe55-f0fb-4326-9bfe-52429e2ab76d)

![Untitled](https://github.com/SeungYeop-Han/cotejunbi/assets/106862797/bde4c81d-690c-4941-91be-07a0aa96c397)

![Untitled](https://github.com/SeungYeop-Han/cotejunbi/assets/106862797/f97a472c-faa7-4a2f-b63f-12f24885cc52)

- 3회 평균 수행 시간 = 1830.7 ms
- 가지치기를 했는데 오히려 시간이 두 배 가량 더 걸렸음
- 왜????????? whyyyy?????????????????
- 아는 사람 코멘트 좀

---
