## í•´ê²°í•œ ë¬¸ì œ

![image](https://github.com/SeungYeop-Han/cotejunbi/assets/106862797/a340b8da-7542-4dba-9f80-648d37b4182b)

ğŸ‘‰ğŸ» [ë¬¸ì œ ë§í¬](https://www.acmicpc.net/problem/16935)

## ë¬¸ì œ ë¶„ì„ ë° ì ‘ê·¼ ë°©ì‹

- NxM ë°°ì—´ì— ì¼ë ¨ì˜ ì—°ì‚°ì„ ìˆœì„œëŒ€ë¡œ ì ìš©í•˜ëŠ” ë¬¸ì œì´ë‹¤.
- N, Mì€ ì§ìˆ˜ì´ë¯€ë¡œ ì–¸ì œë‚˜ ì‚¬ë¶„ë©´ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆë‹¤.
    
    ```
    1 1 1 1 2 2 2 2
    1 1 1 1 2 2 2 2
    1 1 1 1 2 2 2 2
    4 4 4 4 3 3 3 3
    4 4 4 4 3 3 3 3
    4 4 4 4 3 3 3 3
    ```
    
- ì—°ì‚°ì€ 1ë²ˆ ì—°ì‚°ë¶€í„° 6ë²ˆ ì—°ì‚°ê¹Œì§€ ìˆìœ¼ë©° ê°ê°ì€ ì•„ë˜ì™€ ê°™ë‹¤.
    1. ìƒí•˜ ë°˜ì „
    2. ì¢Œìš° ë°˜ì „
    3. ì‹œê³„ ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „
        
        ![Untitled](https://github.com/SeungYeop-Han/cotejunbi/assets/106862797/e98e300b-8152-44f8-8450-38728f4483db)
        
    4. ë°˜ì‹œê³„ ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „

        â†’ ìœ„ì™€ ê°™ì€ ë°©ë²•ìœ¼ë¡œ

    5. ì‹œê³„ ë°©í–¥ìœ¼ë¡œ ì‚¬ë¶„ë©´ ì´ë™
        
        ```
        1 1 1 1 2 2 2 2    â†’    4 4 4 4 1 1 1 1
        1 1 1 1 2 2 2 2    â†’    4 4 4 4 1 1 1 1
        1 1 1 1 2 2 2 2    â†’    4 4 4 4 1 1 1 1
        4 4 4 4 3 3 3 3    â†’    3 3 3 3 2 2 2 2
        4 4 4 4 3 3 3 3    â†’    3 3 3 3 2 2 2 2
        4 4 4 4 3 3 3 3    â†’    3 3 3 3 2 2 2 2
        ```
        
    6. ë°˜ì‹œê³„ ë°©í–¥ìœ¼ë¡œ ì‚¬ë¶„ë©´ ì´ë™
        
        ```
        1 1 1 1 2 2 2 2    â†’    2 2 2 2 3 3 3 3
        1 1 1 1 2 2 2 2    â†’    2 2 2 2 3 3 3 3
        1 1 1 1 2 2 2 2    â†’    2 2 2 2 3 3 3 3
        4 4 4 4 3 3 3 3    â†’    1 1 1 1 4 4 4 4
        4 4 4 4 3 3 3 3    â†’    1 1 1 1 4 4 4 4
        4 4 4 4 3 3 3 3    â†’    1 1 1 1 4 4 4 4
        ```

## ì†ŒìŠ¤ì½”ë“œ
```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

    // ìƒíƒœ
    int row, col, numOfOperation;
    int[][] board;
    int[] operations;

    enum Direction {
        CLOCKWISE,
        COUNTER_CLOCKWISE
    }

    void solution() throws Exception {

        initState();

        for (int opCode: operations) {
            switch (opCode) {
                case 1: inverseVertical(); break;
                case 2: inverseHorizontal(); break;
                case 3: rotate(Direction.CLOCKWISE); break;
                case 4: rotate(Direction.COUNTER_CLOCKWISE); break;
                case 5: shuffleQuadrant(Direction.CLOCKWISE); break;
                case 6: shuffleQuadrant(Direction.COUNTER_CLOCKWISE); break;
                default: throw new RuntimeException("ì˜ˆìƒì¹˜ ëª»í•œ opCode");
            }
        }

        printAnswer();
    }

    void inverseVertical() {
        int[][] tempBoard = new int[row][col];
        for (int iRow = 0; iRow < row; iRow++) {
            int iOppositeRow = row - iRow - 1;
            tempBoard[iOppositeRow] = board[iRow];
        }
        board = tempBoard;
    }

    void inverseHorizontal() {
        int[][] tempBoard = new int[row][col];
        for (int iRow = 0; iRow < row; iRow++) {
            for (int iCol = 0; iCol < col; iCol++) {
                int iOppositeCol = col - iCol - 1;
                tempBoard[iRow][iOppositeCol] = board[iRow][iCol];
            }
        }
        board = tempBoard;
    }

    /**
     * ì‹œê³„ ë˜ëŠ” ë°˜ì‹œê³„ ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „
     * rowì™€ colì´ ë°”ë€œì— ìœ ì˜
     */
    void rotate(Direction direction) {
        int[][] tempBoard = new int[col][row];

        for (int iRow = 0; iRow < row; iRow++) {
            for (int iCol = 0; iCol < col; iCol++) {

                if (direction == Direction.CLOCKWISE) {
                    int iOppositeRow = row - iRow - 1;
                    tempBoard[iCol][iOppositeRow] = board[iRow][iCol];
                } else {
                    int iOppositeCol = col - iCol - 1;
                    tempBoard[iOppositeCol][iRow] = board[iRow][iCol];
                }
            }
        }

        // swap
        int temp = row;
        row = col;
        col = temp;
        board = tempBoard;
    }

    /**
     * ì‹œê³„ ë˜ëŠ” ë°˜ì‹œê³„ ë°©í–¥ìœ¼ë¡œ ì‚¬ë¶„ë©´ ì´ë™
     */
    void shuffleQuadrant(Direction direction) {
        int quadHeight = row / 2;
        int quadWidth = col / 2;
        int[][] quadrantEntryPoints
                = new int[][]{{0, 0}, {0, quadWidth}, {quadHeight, quadWidth}, {quadHeight, 0}};
        int[][] tempBoard = new int[row][col];
        
        // ì‚¬ë¶„ë©´ ìˆœíšŒ(1 -> 2 -> 3 -> 4)
        for (int iQuad = 0; iQuad < 4; iQuad++) {
            
            int iRow = quadrantEntryPoints[iQuad][0];
            int iCol = quadrantEntryPoints[iQuad][1];

            int iNextQuad;
            if (direction == Direction.CLOCKWISE) {
                iNextQuad = (iQuad + 1) % 4;
            } else {
                iNextQuad = (iQuad + 3) % 4;
            }
            
            int iRowNext = quadrantEntryPoints[iNextQuad][0];
            int iColNext = quadrantEntryPoints[iNextQuad][1];

            for (int i = 0; i < quadHeight; i++) {
                for (int j = 0; j < quadWidth; j++) {
                    tempBoard[iRowNext + i][iColNext + j] = board[iRow + i][iCol + j];
                }
            }
        }

        board = tempBoard;
    }

    void initState() throws Exception {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            row = Integer.parseInt(st.nextToken());
            col = Integer.parseInt(st.nextToken());
            numOfOperation = Integer.parseInt(st.nextToken());

            board = new int[row][col];
            operations = new int[numOfOperation];

            for (int iRow = 0; iRow < row; iRow++) {
                st = new StringTokenizer(br.readLine());
                for (int iCol = 0; iCol < col; iCol++) {
                    board[iRow][iCol] = Integer.parseInt(st.nextToken());
                }
            }

            st = new StringTokenizer(br.readLine());
            for (int i = 0; i < numOfOperation; i++) {
                operations[i] = Integer.parseInt(st.nextToken());
            }
        }
    }

    void printAnswer() {
        StringBuilder sb = new StringBuilder();
        for (int iRow = 0; iRow < row; iRow++) {
            for (int iCol = 0; iCol < col; iCol++) {
                sb.append(board[iRow][iCol]);
                sb.append(" ");
            }
            sb.append("\n");
        }
        System.out.println(sb);
    }

    public static void main(String[] args) throws Exception {
        new Main().solution();
    }
}
```
